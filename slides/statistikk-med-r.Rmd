---
title: "Statistikk med R"
author: "Ove Haugland Jakobsen og Eivor Hovde Hoff"
date: "7. april 2021"
always_allow_html: yes
output:
  ioslides_presentation:
    fig_retina: 2
    widescreen: yes
    css: ../assets/styles.min.css
    logo: ../assets/rr-logo.svg
---

```{r setup, include=FALSE}
if (!require(tufte)) install.packages('tufte')
knitr::opts_chunk$set(echo = FALSE)
set.seed(42)
library(haven); library(tibble); library(ggplot2)
```

# Oversikt over kurset

## Oversikt over kurset

* Importere data til R
  - Import av data
  - Eksport av data
* Deskriptiv statistikk med R eksplorativ analyse
  - Eksplorerende analyse
  - Håndtering av missing
  - Mild introduksjon til å vaske data
* Modellbygging i R

## Rask repetisjon



# Importere data

## Kilder til data {.flexbox .vleft .extraspace}

* Flatfiler (semikomma- eller kommaseparerte filer)
* Excel-filer
* Filer fra statistikkpakker (Stata, SAS, SPSS)
* Databaser (SQL)
* APIer over internett (Stortingets API, SSB)
* Skytjenester (AWS, Hadoop)
* Webscraping! `r emo::ji('wink')`

## Flatfiler {.flexbox .vleft}

* R har innebygde funksjoner for å lese inn flatfiler
* Flatfiler kommer i flere typer
  - *kommaseparerte filer*: har som regel filendelse `.csv` eller `.txt`
  - *semikolonseparerte filer*: vanlig i _Europa_ og som regel med filendelse `.csv` eller `.txt`
  - *tabulatorseparerte filer*: har som regel filendelse `.txt` eller `.tsv`
  
## Kommaseparerte filer

Du kan undersøke filstrukturen med funksjonen `readLines()`:

```{r, eval=FALSE, echo=TRUE}
# Leser de tre første linjene av fila
readLines('carseats.csv', n = 3)
```


```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
readLines('carseats.csv', n = 3)
```

Legg merke til at første rad i fila inneholder _kolonnenavn_, fila er _kommaseparert_, bruker `"` for å markere tekst, og har `.` som desimaltegn.

## Kommaseparerte filer (2)

Vi kan lese inn _kommaseparerte_ filer med `read.csv()` og _semikolonseparerte filer med `read.csv2()`.

```{r, eval=FALSE, echo=TRUE}
df <- read.csv('carseats.csv')
print(df[1:5, 1:8])
```


```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
df <- read.csv('carseats.csv')
print(df[1:5, 1:8])
```

## Kommaseparerte filer (3)

Sjekk data med `str()`
og `head()`

## Kommaseparerte filer (4)

`read.csv()` har flere argumenter vi kan bruke for å styre hvordan fila blir lest inn:

```{r, eval=FALSE, echo=TRUE}
df <- read.csv(
  'carseats.csv',
  header = TRUE,  # Kolonnenavn i første rad?
  sep = ',',      # Skilletegn for celleverdier
  dec = '.',      # Desimaltegn
  quote = '"',    # Tekstkvalifikator (kan være FALSE)
  skip = 10       # Hopp over n rader fra toppen av fila
)
```

Se flere muligheter med `?read.csv`

## Tabulatorseparerte filer

Her er samme fil, men denne har en annen struktur:

```{r, eval=FALSE, echo=TRUE}
# Leser de tre første linjene av fila
readLines('carseats.tsv', n = 3)
```


```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
readLines('carseats.tsv', n = 3)
```

Legg merke til at første rad i fila inneholder _kolonnenavn_, men denne fila er _tabulatorseparert_ (`\t` er tegn for tabulator), det er ingen tekstkvalifikator, og `,` er brukt som desimaltegn.

## Tabulatorseparerte filer (2)

## Les inn data med basefunksjoner {.flexbox .vleft}

* R har innebygde funksjoner (fra `utils`) for å lese inn tekstbaserte filer
* Vanligste dataformat for tabulære data er CSV
* Vi kan lese inn tabulære data fra tekstfiler med `read.table`
* Funksjonen `read.delim` er en variant av `read.table` som leser inn _tabulatorseparerte_ filer
* Funksjonen `read.csv` er en variant av `read.table` som leser inn _kommaseparerte_ filer
* Funksjonen `read.csv2` er en variant av `read.table` som leser inn _semikolonseparerte_ filer

## Vanlige problemer {.flexbox .vleft}

To vanlige problemer med å lese inn data:

1. R forsøker å konvertere tekstvariabler til faktorer
2. Norske tegn (alle ikke-ASCII-tegn) leses inn feil på grunn av problemer med tekstkoding (encoding)

Løsninger:

* Les inn data med argumentet `stringsAsFactors` satt til `FALSE`
* Tekstkodingen kan angis med `encoding`: `CP1252` er vanlig på Windows, mens `UTF-8` er vanlig på macOS og web (for det meste)
* **Hvis du kan velge tekstkoding på rådata, velg alltid UTF-8**

## Oppgaver {.flexbox .vleft}

**Husk at du kan bruke `?read.csv` for å få informasjon om funksjonen!**

1. Les inn fila `carseats.csv` som `carseats` med `read.csv()`
2. Bruk `head(carseats)` for å se de første observasjonene
3. Bruk `sum()` og `mean()` for å finne sum og gjennomsnitt på variablene `Sales` og `Price`
4. Les inn fila på nytt som `carseats_chr` men uten konvertering av tekst til faktorer. Sjekk resultatet med `class(carseats_chr$Urban)`

## readxl {.flexbox .vleft}

To viktige funksjoner:

* `excel_sheets` og
* `read_excel`

`read_excel()` støtter både `xlsx` og `xls`-filer, og vil gjette type basert på filnavn. Hvis du vet hvilket format du skal lese, kan du bruke `read_xls()` eller `read_xlsx()`

## Oppgaver {.flexbox .vleft .extraspace}

1. Last inn pakken `readxl` med `library(readxl)`
2. Les inn fila `carseats.xlsx` som `carseats_excel` med `read_xlsx` fra pakken `readxl`
3. Bruk `summary` på `carseats_excel`. Hva er median for variabelen `Price`?
4. Er `carseats` og `carseats_excel` like? Hvorfor ikke?*

* Hint: likhet kan vurderes med `identical`. Husk også funksjonene `class` og `str`.

## Les inn data fra Stata

Vi kan lese inn data fra Stata med pakken `heaven`.

```{r, eval=FALSE, echo=TRUE}
library(haven)
df <- read_dta('kompensasjonsordning.dta')
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
library(haven)
komp_ordning <- read_dta('kompensasjonsordning.dta')
head(komp_ordning)
```

# Deskriptiv statistikk

## Deskriptiv statistikk {.flexbox .vleft .extraspace}

1. **Beskrive data** 
    + basefunksjoner i R
2. **Visualisere data**
    + basefunksjoner i R og pakken `ggplot2`
3. **(Mild introduksjon til) datavasking**


**Noen nevnbare pakker**

* `dplyr` og `tidyverse`
* `data.table`

# Beskrive data

## Repetisjon av noen funksjoner {.flexbox .vleft}

* `dim()` : dimensjoner i datasettet
* `nrow()` og `ncol()` : antall rader og kolonner
* `str()` : struktur
* `head()`: øverste del av datasett
* `tail()`: nederste del av datasett

## Enveis og toveis tabeller  {.flexbox .vleft}

* `table(x, ...)` 
* `aggregate(x, by, FUN)`

```{r, echo=FALSE, eval=FALSE}

table(x, ...,          # Data
      useNA = 'ifany'  # Inkludering av missing  
      )

aggregate(x,           # Data
          by,          # Liste over grupperingsvariabler
          FUN          # Funksjon som skal brukes
          )
```


## Enveis og toveis tabeller - table()

```{r, echo=FALSE, eval=FALSE}

table(x, ...,          # Data
      useNA = 'ifany'  # Inkludering av missing  
      )
```

```{r, echo=FALSE}
carseats <- ISLR::Carseats
carseats$Urban[35:44] <- NA
```

```{r, echo=TRUE, eval=TRUE}
# Frekvenstabell over antall Urbane lokasjoner
table(carseats$Urban)
```

```{r, echo=TRUE, eval=TRUE}
# Inkluder missing
table(carseats$Urban, useNA = 'ifany')
```

## Enveis og toveis tabeller - table()

```{r, echo=TRUE, eval=TRUE}
# Lage et tabellobjekt 
tbl <- table(carseats$Urban, carseats$ShelveLoc)

# Bruker proportions() med margin = 1 for andeler fordelt på radene
proportions(tbl, margin = 1)
```

```{r, echo=FALSE}
carseats <- ISLR::Carseats
```


## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=FALSE}

aggregate(x,           # Data frame
          by,          # Liste over grupperingsvariabler
          FUN          # Funksjon som skal brukes
          )
```

* Aggregere verdier i en data frame
* Output er en data frame

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE}
# Vi aggregerer gjennomsnittlig salg fordelt på Urban og ShelveLoc (kvalitet på hylleplassering)
aggregate(carseats$Sales, 
          by = list(UrbanPop = carseats$Urban, Hylleplassering = carseats$ShelveLoc), 
          FUN = mean)
```

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE}
# Vi kan også lage en ny aggregert data frame

agg_salg <- aggregate(carseats$Sales, 
                      list(UrbanPop = carseats$Urban, 
                           Hylleplassering = carseats$ShelveLoc), 
                      mean, na.rm = TRUE)

colnames(agg_salg)[colnames(agg_salg) == 'x'] <- 'Snitt_Salg'

head(agg_salg)
```

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE, warning=FALSE}
# Også mulig å aggregere på hele datasettet
aggregate(carseats, list(Hylleplassering = carseats$ShelveLoc), mean, na.rm=TRUE)
```

## Sentraltendens og spredning {.flexbox .vleft}

Vennlig påminnelse om målenivå

+---------------+---------------+----------------+-----------+
| Type data     | Målenivå      | Sentraltendens | Spredning |
+===============+===============+================+===========+
| Kategoriske   | Nominal       | Modus          | Ingen     |
|               |               |                |           |
|               | Ordinal       | Modus, median  | IQR       |
|               |               |                |           |   
+---------------+---------------+----------------+-----------+
| Kontinuerlige | Intervall/    | Modus          | Range     |
|               |               |                |           |
|               | Forholdstall  | Median         | Varians   |
|               |               |                |           |
|               |               | Gjennomsnitt   | Std.dev   |
|               |               |                |           |
|               |               |                | IQR       |
+---------------+---------------+----------------+-----------+

## `summary()`

```{r, echo=TRUE, eval=TRUE}
# Data frame summary, her utvalgte kolonner
summary(carseats[, 1:4])

# En vektor i en dataframe
summary(carseats$Sales)

```

## `summary()`

```{r, echo=TRUE, eval=TRUE}
# En vektor
konk_pris <- carseats$CompPrice
summary(konk_pris)
```

## Sentraltendens

```{r, echo=TRUE, eval=TRUE}

# Median
median(carseats$CompPrice)

# Gjennomsnitt
mean(carseats$CompPrice)

```

## Sentraltendens

Husk argumentet `na.rm`!
```{r, echo=TRUE, eval=TRUE}
# En vektor hvor minst én verdi er missing
x <- c(1:15, NA, 17:20)
```

```{r, echo=TRUE, eval=TRUE}
mean(x)

mean(x, na.rm = TRUE)

```

## Spredning

```{r, echo=TRUE, eval=TRUE}
# Funksjonen range() gir min og maks-verdi
range(carseats$Price)

# Range: avstanden mellom min og maks
max(carseats$Price)-min(carseats$Price) 

# Kvartiler/persentiler
quantile(carseats$Price)

quantile(carseats$Price, probs = 0.50)

quantile(carseats$Price, probs = c(0.25, 0.50, 0.75))

```

## Spredning

```{r, echo=TRUE, eval=TRUE}
# IQR (Avstand mellom Q1 Q3)
IQR(carseats$Price)

# Standardavvik
sd(carseats$Sales)

```


## Oversikt over noen funksjoner

+-------------------------+-------------------------------------+
| Funksjon                | Beskrivelse                         |
+=========================+=====================================+
| summary(x)              | Oppsummerende deskriptiv statistikk |
+-------------------------+-------------------------------------+
| min(x), max(x)          | Min- og maksverdier                 |                   |
+-------------------------+-------------------------------------+
| mean(x), median(x)      | Gjennomsnitt og median              |
+-------------------------+-------------------------------------+
| range(x)                | Min- og maksverdier                 |
+-------------------------+-------------------------------------+
| IQR(x)                  | Avstanden mellom Q1 og Q3           |
+-------------------------+-------------------------------------+
| quantile(x)             | Kvartiler                           |
+-------------------------+-------------------------------------+
| sd(x)                   | Standardavvik                       |                 
+-------------------------+-------------------------------------+

## Oppgaver {.flexbox .vleft. .extraspace}

Les inn datasettet `komp_oppgave.RDS` med `komp_oppgave <- readRDS('komp_oppgave.RDS')`

1. Lag en frekvenstabell basert på `sektorkode`.
2. Bruk `aggregate()` og `sum()` til å summere `belop` fordelt på `sektorkode`.
3. Finn median og gjennomsnitt til variabelen `belop`. Tolk.
4. Bruk `quantile()`-funksjonen til å printe ut 25te og 75te persentil. Tolk.
5. Finn IQR uten å bruke funksjonen IQR basert på tallene over.
6. Får du det samme tallet med funksjonen `IQR()`?

## Visualisere - base R {.flexbox .vleft}

* `hist(x, ...)`
* `boxplot(x, ...)`
* `plot(x, y, ...)`

```{r, echo=FALSE, eval=FALSE}

# Histogram
hist(x, 
     breaks = n,
     freq = TRUE,
     main = "Tittel", 
     ...)

# Boxplot
boxplot(x, ...)

boxplot(x1~x2,
        data = df, 
        ...)

```

## Histogram {.flexbox .vleft}

```{r, echo=TRUE, eval=TRUE}
hist(carseats$Sales)
```

## Histogram

```{r, echo=TRUE, eval=TRUE}
# Endre antallet intervaller (bins/breaks)
hist(carseats$Sales, breaks = 15)
```

## Histogram
```{r, echo=TRUE, eval=TRUE}
# Endre fra frekvenser til 'density'
hist(carseats$Sales, freq = FALSE)
```

## Histogram
```{r, echo=TRUE, eval=TRUE}
hist(carseats$Sales, main = "Antall solgte bilseter (1000)")
rug(carseats$Sales, main = "Antall solgte bilseter (1000)")
```

## Boxplot

```{r, echo=TRUE, eval=TRUE}
boxplot(carseats$Sales)
```

## Boxplot

```{r, echo=TRUE, eval=TRUE}
boxplot(Sales~ShelveLoc, data = carseats)
```

## Boxplot

```{r, echo=TRUE, eval=TRUE}
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue")
```

## Boxplot

```{r, echo=TRUE, eval=TRUE}
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue", 
        main = "Salg fordelt på hylleplassering")
```


## Visualisering - `ggplot2` {.flexbox .vleft .extraspace}

* Uendelige muligheter for enkle og kompliserte visualiseringer som ser bra ut
* Se gjerne [ggplot2 cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf)

```{r, echo=TRUE, eval=FALSE}
ggplot(data,    # data
       aes(  
         x,     # x-aksen
         y,     # y-aksen
         ...    # (mange) andre argumenter
       )) +
  geom_*() +   # hvordan datapunktene skal vises og hvilke egenskaper de skal ha
  stat_*() +   # visualisering av transformasjoner
  scale_*() +  # hvordan plottet visualiserer verdiene
  theme_*()    # tema
```

## En meget mangelfull oversikt OPPDATER/KUTT {.flexbox .vleft .extraspace}

ggplot(data, aes(x, y, **color**, **alpha**, **size**,  **shape**, ...))

+ geom_: _point()_, _line()_, _bar()_, _boxplot()_, _area()_ ...

* Geometries kan også gis ulike egenskaper
   - geom_point(**alpha**, **size**, **color**, ...)


## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price))

```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price)) + geom_point()

```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price, color = Urban)) + geom_point()
```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=FALSE}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + geom_point() +
  stat_smooth()
```

## ggplot2 - Stegvis eksempel

```{r, echo=FALSE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + geom_point() +
  stat_smooth()
```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=FALSE}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_point(alpha = 0.3) + 
  stat_smooth()
```

## ggplot2 - Stegvis eksempel

```{r, echo=FALSE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_point(alpha = 0.3) + 
  stat_smooth()
```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=FALSE}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_point(alpha = 0.3) + 
  stat_smooth() +
  theme_minimal()
```

## ggplot2 - Stegvis eksempel

```{r, echo=FALSE, eval=TRUE, fig.align='right'}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_point(alpha = 0.3) + 
  stat_smooth() +
  theme_minimal()
```

## ggplot2 - Stegvis eksempel

```{r, echo=TRUE, eval=FALSE}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_smooth(alpha = 0.3) + 
  theme_minimal()
```

## ggplot2 - Stegvis eksempel

```{r, echo=FALSE, eval=TRUE}
ggplot(carseats, aes(x = Sales, y = Price, col = Urban)) + 
  geom_smooth(alpha = 0.3) + 
  theme_minimal()
```

## Legg til et kult eksempel bare for å vise
https://www.r-graph-gallery.com/ggplot2-package.html

## Oppgaver

Les inn datasettet `komp_oppgave.RDS` med `komp_oppgave <- readRDS('komp_oppgave.RDS')`

1. Lag et boxplot med `boxplot()`
2. Lag et boxplot med `ggplot()`
3. Oppgave 3
4. Oppgave 4
5. Oppgave 5


# (Mild introduksjon til) datavasking
## Data er ofte _dirty_ {.flexbox .vleft}

Menneskelige og tekniske feil fører til _dirty data_

* Datavasking er noe av det viktigste vi gjør
* Bli godt kjent med egne data
* Planlegg god tid til datavasking

## Dirty data - vanlige sjekker {.flexbox .vleft}

* Missing data 
* Datatype
* Range
* Duplikater
* Samsvar på tvers
* Tekstvariabler


## Missing data - et uunngåelig problem {.flexbox .vleft .extraspace}

+-------------------------------+----------------------------------------+-------------------------+
| Type missing data             | Beskrivelse                            | Eksempel                |
+===============================+========================================+=========================+
| Helt tilfeldig                | Ingen sammenheng med andre observerte/ | Feil på blodtrykksmåler |
|                               |  uobserverte verdier                   | i blodtrykksstudie      |
| _Missing completely at random_|                                        |                         |
+-------------------------------+----------------------------------------+-------------------------+
| Betinget tilfeldig            | Sammenheng med andre _observerte_      | Yngre møter opp         |
|                               | verdier                                | sjeldnere enn eldre     |  
| _Missing at random_           |                                        |                         |
+-------------------------------+----------------------------------------+-------------------------+
| Ikke-tilfeldig                | Sammenheng med andre _uobserverte_     | Eldre med høyt blodtrykk|
|                               | verdier                                | møter sjeldnere enn     |  
| _Missing not at random_       |                                        | andre eldre             |
+-------------------------------+----------------------------------------+-------------------------+

## Håndtering av missing data {.flexbox .vleft .extraspace}

* *Droppe observasjoner*
* *Imputere (fylle inn verdier)* basert på
    + statistiske mål (gjennomsnitt, median)
    + kjennskap til dataene
    + algoritmer/maskinlæring

* *Løsningen avhenger av*
    + hvor godt du kjenner data
    + type missing du antar at du har

## Missing data - funksjoner i R 

* Missingverdier i R: `NA`, `NaN` 
* Vit hvilke eventuelle andre verdier i ditt datasett som er missing (eks. 99, 0)

```{r, eval=TRUE, echo=TRUE}
# Missing
is.na(c(NA, NaN)) 

# Ikke missing
is.na(0)

```

## Missing data - funksjoner i R 
```{r, eval=TRUE, echo=TRUE}
alder <- c(27, 40, 34, 25, 57, 45, 87, NA, 38, NA, 90)

# Elementvis test for missing i vektor alder
is.na(alder)

# Test for om alder inneholder missingverdier
anyNA(alder)

```


## Missing data - funksjoner i R 

```{r, eval=TRUE, echo=TRUE}
# Hovedregel: NA + noe = NA
mean(alder)

# Fjern missingverdier når funksjonen kjøres
mean(alder, na.rm = TRUE)

# Fjern missingverdier fra alder
na.omit(alder)

```

## Missing data - funksjoner i R 
```{r, eval=TRUE, echo=TRUE}
# Missingverdier i en data frame
data("airquality")
anyNA(airquality)

# Antall verdier missing
sum(is.na(airquality))

```

## Missing data - funksjoner i R 

```{r, eval=TRUE, echo=TRUE}
# Samme hovedregel
sapply(airquality, mean)

# Ekskluderer missingverdier når funksjoner kjøres
sapply(airquality, mean, na.rm=TRUE)

```

## Missing data - visualisering

```{r, eval=TRUE, echo=TRUE}
naniar::vis_miss(airquality)
```

## Videre med datavasking

```{r, eval=TRUE, echo=FALSE}
dato <- c('01/03/2020', '01/04/2020', '01/05/2020', '01/06/2020', '01/07/2020', '01/08/2020', '01/09/2020', '01/10/2020','01/11/2020','01/12/2020')
hk <- data.frame(
  navn = c(rep('Ove', 10), rep('Eivor', 10), rep('Lars', 10)),
  alder = c(rep(36, 10) , rep(34, 8), NA ,NA, rep(29, 8), NA, 58),
  dato = rep(dato, 3),
  stemning = c('OK', 'Glad', 'Superglad', 'Glad', 'Langt nede','Nede', 'Superglad', 'Langt nede','OK', 'Glad', 'Nede','Nede', 'Superglad', 'Langt nede','Glad', 'Langt nede', 'Glad', 'Langt nede','Nede', 'Superglad', 'Langt nede', 'OK', 'Superglad', 'Glad', 'nede','nede', 'Glad', 'OK', 'Ok', 'langt nede')
)

hk <- rbind(hk, hk[rep(1,5),])
hk$dato[13] <- '01/05/2023'
```
Et eksempeldatasett
Humøret til Ove, Eivor og Lars i perioden 01.03.2020-01.12.2020

```{r, eval=TRUE, echo=TRUE}
str(hk)
```

## Datatype
```{r, eval=TRUE, echo=TRUE}
# Sjekker datatypen til dato
class(hk$dato)

# Ser på noen av verdiene
hk$dato[1:5]

```

## En kort tur innom håndtering av datoer {.flexbox .vleft}

Vi må fortelle R hvilket format datostrengene har

* `?strptime` for oversikt over formatangivelser
* `as.Date(x, format)` for å konvertere til dato
* `as.POSIXct(x, format)` for å konvertere til datetime

## En kort tur innom håndtering av datoer {.flexbox .vleft}

| Tekstdato                 | Format               |       
| --------------------------|:--------------------:|
| "01/03/2020"              | `%d/%m/%Y`           |
| "20200301"                | `%Y%m%d`             |
| "1. mar 2020"             | `%d. %b %Y`          |
| "1. mars 2020 15:17:23"   | `%d. %B %Y %H:%M:%S` |
| "01-03-20 14:14"          | `%d-%m-%y %H:%M`     | 

## En kort tur innom håndtering av datoer

```{r, eval=TRUE, echo=TRUE}
# Konvertere til dato med as.Date() 
as.Date('01.03.2020', format = "%d.%m.%Y")

# Konverterer til datetime med as.POSIXct()
as.POSIXct('01.03.2020 13:09', format = "%d.%m.%Y %H:%M")

```

## Datatype
```{r, eval=TRUE, echo=TRUE}
# hk$dato[1:3]
hk$dato2 <- as.Date(hk$dato, format = '%d/%m/%Y')
hk$dato2 [1:5]

# Sjekker datatype
class(hk$dato2)
```

## Range-problematikk
```{r, eval=TRUE, echo=TRUE}
# Faller alle verdiene innenfor riktig intervall?
range(hk$dato2)

# Finner observasjonen(e) med dato lengre fram i tid enn 01.12.2020
which(hk$dato2 > as.Date('2020-12-01'))
```

## Range-problematikk
```{r, eval=TRUE, echo=TRUE}
# Ser på denne observasjonen
hk[13,]

```

```{r, eval=TRUE, echo=TRUE}
# I dette tilfellet endre til det som sannsynligvis er den riktige datoen
hk$dato2[13] <- as.Date('2020-05-01')
```

## Duplikater {.flexbox .vleft .extraspace}

Kjenn observasjonsenheten
 
Nyttige funksjoner

* `unique()`
* `length()`
* `duplicated()`
* `table()`

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Printer ut unike verdier i en vektor
unique(hk$navn)

# Antall unike verdier i en vektor
length(unique(hk$navn))
```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Sjekker om navnekolonnen har duplikater
duplicated(hk$navn)

# Antall duplikater for navn
table(duplicated(hk$navn))
```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Vi kan sjekke for fulle duplikater
table(duplicated(hk))

# Ser på de duplikate radene
hk[duplicated(hk), ]

```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Lager et nytt datasett uten duplikater
hk_vasket <- hk[!duplicated(hk),]

# Sjekker at det ikke er noen duplikater
table(duplicated(hk_vasket))
```

## Tekstvariabler

| Beskrivelse                                       | Funksjon(er)         |       
| --------------------------------------------------|:--------------------:|
| Slå sammen tekststrenger                          | `paste`, `paste0`    |
| Fjern mellomrom fra starten/slutten av en streng  | `trimws`             |
| Finn antall tegn i en tekststreng                 | `nchar`              |
| Split elementer i en tekststreng                  | `strsplit`           |
| Konverter en streng til store/små bokstaver       | `toupper`, `tolower` | 
| Hent ut eller erstatt deler av en tekststreng     | `substr`, `substring`|

## Tekstvariabler

```{r, eval=TRUE, echo=TRUE}
# Unike verdier av stemning-variabelen
unique(hk_vasket$stemning)

# Konverterer til små bokstaver
hk_vasket$stemning <- tolower(hk_vasket$stemning)
unique(hk_vasket$stemning)
```

## Regulære uttrykk {.flexbox .vleft .extrapace}

* **Regulære uttrykk** er en nyttig metode for å finne og behandle ulike *mønstre* i tekststrenger 

* Kan brukes på tvers av en rekke ulike programmeringsspråk 

* For en interaktiv innføring gå til [regex101.com](https://regex101.com/)

* Se [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html) 
for en oversikt over regulære uttrykk i R

* Vi legger ved fjorårets slides om regulære uttrykk


## Oppgave
1. Les inn datasettet carseats_dirty med `readRDS(carseats_dirty.RDS)`
2. Oppgave 2
3. Oppgave 3
4. Oppgave 4
5. Oppgave 5



# Regresjonsbaserte modeller

## Lineære modeller

$$Y=\alpha+\beta_1x_1+\beta_2x_2+\epsilon$$

$$\bar{Y}$$

## Formelobjektet

## Kategoriske variabler (factor)

* R håndterer kategoriske variabler med datatypen `factor`
* Frem til versjon 4, ble alle tekstkolonner automatisk importer om `factor` og ikke `character`
* Faktorvariabler kan brukes direkte i regresjonsmodeller _uten_ omkoding (det opprettes automatisk k-1 dummyvariabler)
* Vi kan se dummyvariablene R oppretter med funksjonen `contrasts()`

## Enkel regresjonsmodell

* Vi kan bruke den innebygde funksjonen `lm()` for å lage en regresjonsmodell
* Vi bruker formelobjektet for å spesifisere modellen
* Hvis vi kjører funksjonen direkte, får vi ut koeffisientene til modellen
* Vi kan også lagre modellen til et eget objekt som vi kan jobbe videre med

## Enkel regresjonsmodell (2)

Eksempel:

```{r, eval=FALSE, echo=TRUE}
library(MASS)
lm.mod <- lm(medv ~ crim, data = Boston)
summary(lm.mod)
```

## Enkel regresjonsmodell (3)

```{r, eval=TRUE, echo=FALSE}
library(MASS)
lm.mod <- lm(medv ~ crim, data = Boston)
summary(lm.mod)
```

coef()
confint()

predict(mod, data, interval='confidence')


## Multippel regresjonsmodell

$$Y=\alpha+\beta_1x_1+\beta_2x_2...\beta_nx_n+\epsilon$$

* Vi kan gå fra en enkel regresjonsmodell til en multippel regresjonsmodell ved å utvide formelobjektet
* For en vanlig additiv modell, bruker vi `+` for å legge til uavhengige variabler i modellen

Eksempel

```{r}
lm(medv ~ lstat * age, data = Boston)
```


## Oppdatere modeller

## Vurdere modeller


## Samspill

```{r}
samspill.mod <- lm(medv ~ lstat * age, data = Boston)
summary(samspill.mod)
```


## Transformasjoner

```{r}
trans.mod <- lm(medv ~ lstat + I(lstat^2), data = Boston)
summary(trans.mod)
```

## Transformasjoner

```{r}
trans.mod2 <- lm(medv ~ poly(lstat, 4), data = Boston)
summary(trans.mod2)
```

## Transformasjoner

```{r}
trans.mod3 <- lm(medv ~ log(rm), data = Boston)
summary(trans.mod3)
```


## Standardisering

Håndtere at ulike variabler har ulik måleenhet
I regresjonsanalyser kan vi se på de standardiserte beta-koeffisientene, men enkelte algoritmer er sensitive for målenivå (forskjellig resultat om en variabel er målt i kroner eller dollar)
Gjennomsnitt på 0 og standardavvik på 1
God praksis å skalere variabler
I R kan vi gjøre dette med funksjonen `scale()`

## Standardisering

```{r, echo=TRUE}
lstat <- Boston$lstat
mean(lstat); sd(lstat)
```

```{r, echo=TRUE}
lstat.scaled <- as.vector(scale(lstat))
mean(lstat.scaled); sd(lstat.scaled)
```


## Oppgaver

```{r, eval=FALSE, echo=TRUE}
carseats <- read.csv('carseats.csv', stringsAsFactors = TRUE)
```


```{r, eval=TRUE, echo=FALSE}
carseats <- read.csv(
  sprintf('%s/course-material/statistikk-med-r/carseats.csv', here::here()),
  stringsAsFactors = TRUE)
```

1. Oppgave 1
2. Oppgave 2

## Logistiske modeller

glm()

# Predict-funksjonen

## Predict

```{r, eval=FALSE}
# Lage modell
mod <- lm()
# Bruke modell
preds <- predict(mod, data)

```

## Prediksjon på nye data

```{r, eval=TRUE, echo=FALSE}
default <- ISLR::Default
```


```{r}
set.seed(42)
x <- runif(nrow(default), 0, 1)
x <- ifelse(x < .7, TRUE, FALSE)
table(x)
```

## Prediksjon på nye data

```{r}
default.trening <- default[x,]
default.test <- default[!x,]
```

```{r}
mod <- glm(default ~ balance, data = default.trening, family = 'binomial')
preds <- predict(mod, default.test, type = 'response')
preds <- factor(ifelse(preds > .5, 'Yes', 'No'))
```

```{r}
table(preds, default.test$default)
```

```{r}
caret::confusionMatrix(table(preds, default.test$default))
```



## Nyttige pakker

* caret
* mlbench
