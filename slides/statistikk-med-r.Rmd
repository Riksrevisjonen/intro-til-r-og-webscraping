---
title: "Statistikk med R"
author: "Ove Haugland Jakobsen og Eivor Hovde Hoff"
date: "25. oktober 2021"
always_allow_html: yes
output:
  ioslides_presentation:
    fig_retina: 2
    widescreen: yes
    css: ../assets/styles.min.css
    logo: ../assets/rr-logo.svg
---

```{r setup, include=FALSE}
if (!require(tufte)) install.packages('tufte')
knitr::opts_chunk$set(echo = FALSE)
set.seed(42)
library(haven); library(tibble); library(ggplot2)
```

## Oversikt over kurset

* Importere data til R
  - Import av data
  - Eksport av data
* Deskriptiv statistikk med R
  - Eksplorerende analyse
  - Håndtering av missing
  - Mild introduksjon til å vaske data
* Modellbygging i R
  - Lineær regresjon
  - Logistisk regresjon

## Rask repetisjon: _datatyper og strukturer_

| Datatyper | Datastrukturer |
|:---------:|:--------------:|
| Heltall (integers) | **Vektor** |
| Numerisk (float og double) | **Lister** |
| Tekst (character) | **Matrise** |
| Logisk (logical) | **Data frame** |

## Rask repetisjon: _subsetting_

**For vektorer bruker vi indeks**:

```{r, echo=TRUE}
min.vektor <- seq(1, 100, 2)
min.vektor[4:6]
```

**For matriser og data frame bruker vi rad og kolonne-indeks**:

```{r, echo=TRUE}
min.matrise <- matrix(1:100, ncol = 5)
min.matrise[2:4, 1:3]
```

## Rask repetisjon: _subsetting_

**For data frame kan vi også bruke `$` for navngitte kolonner**:

```{r, eval=TRUE, echo=TRUE}
df <- data.frame(tall = 1:20, bokstaver = letters[1:20])
tall <- df$tall
head(tall)
bokstaver <- df$bokstaver[1:10]
bokstaver
```


## Rask repetisjon: _funksjoner_

* Funksjoner kan ha ett eller flere _argumenter_
* Argumenter kan være _posisjonsbaserte_ eller _navngitte_
* Noen argumenter må angis, mens andre er valgfrie (og har da standardverdier)
* Få informasjon om argumenter med `args()` og hjelp til bruk av funksjonen med `?`
* Noen funksjoner er _vektoriserte_

## Rask repetisjon: _kontrollflyt_

* Test for likhet med `==` og ulikhet med `!=`
* Bruk `%in%` for å sjekke om `x` er inkludert i `y` (`x %in% y`), og finn det motsatte med `!(x %in y)`
* Sjekk for større enn `>`, større eller lik `>=`, mindre enn `<` og mindre eller lik `<=`
* R har de logiske operatorene `&` for **og**, `|` for **eller** og `!` for **ikke**
* Vi kan skrive betinget kode med `if (betingelse) { kode hvis sann } else { kode hvis ikke sann }`
* Funksjonen `ifelse()` er en vektorisert funksjon som tester for én betingelse

# Importere data

## Kilder til data {.flexbox .vleft .extraspace}

* Flatfiler (semikomma- eller kommaseparerte filer)
* Excel-filer
* Filer fra statistikkpakker (Stata, SAS, SPSS)
* Strukturerte datafiler som JSON, XML og YAML
* Databaser (SQL)
* APIer over internett (Stortingets API, SSB)
* Skytjenester (AWS, Hadoop)
* Webscraping! `r emo::ji('wink')`

## Flatfiler {.flexbox .vleft}

* R har innebygde funksjoner for å lese inn flatfiler
* Flatfiler kommer i flere typer
  - *kommaseparerte filer*: har som regel filendelse `.csv` eller `.txt`
  - *semikolonseparerte filer*: vanlig i _Europa_ og som regel med filendelse `.csv` eller `.txt`
  - *tabulatorseparerte filer*: har som regel filendelse `.txt` eller `.tsv`
  
## Les inn data med basefunksjoner {.flexbox .vleft}

* R har innebygde funksjoner (fra `utils`) for å lese inn tekstbaserte filer
* Vanligste dataformat for tabulære data er CSV
* Vi kan lese inn tabulære data fra tekstfiler med `read.table`
* Funksjonen `read.delim` er en variant av `read.table` som leser inn _tabulatorseparerte_ filer
* Funksjonen `read.csv` er en variant av `read.table` som leser inn _kommaseparerte_ filer
* Funksjonen `read.csv2` er en variant av `read.table` som leser inn _semikolonseparerte_ filer
  
## Kommaseparerte filer {.build}

Du kan undersøke filstrukturen med funksjonen `readLines()`:

```{r, eval=FALSE, echo=TRUE}
# Leser de tre første linjene av fila
readLines('carseats.csv', n = 3)
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
readLines('carseats.csv', n = 3)
```

Legg merke til at første rad i fila inneholder _kolonnenavn_, fila er _kommaseparert_, bruker `"` for å markere tekst, og har `.` som desimaltegn.

## Kommaseparerte filer (2) {.build}

Vi kan lese inn _kommaseparerte_ filer med `read.csv()` og _semikolonseparerte_ filer med `read.csv2()`.

```{r, eval=FALSE, echo=TRUE}
df <- read.csv('carseats.csv')
print(df[1:5, 1:8])
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
df <- read.csv('carseats.csv')
print(df[1:5, 1:8])
```

## Kommaseparerte filer (3)

`read.csv()` har flere argumenter vi kan bruke for å styre hvordan fila blir lest inn:

```{r, eval=FALSE, echo=TRUE}
df <- read.csv(
  'carseats.csv',
  header = TRUE,  # Kolonnenavn i første rad?
  sep = ',',      # Skilletegn for celleverdier
  dec = '.',      # Desimaltegn
  quote = '"',    # Tekstkvalifikator (kan være FALSE)
  skip = 10       # Hopp over n rader fra toppen av fila
)
```

Se flere muligheter med `?read.csv`

## Tabulatorseparerte filer {.build}

Her er samme fil, men denne har en annen struktur:

```{r, eval=FALSE, echo=TRUE}
# Leser de tre første linjene av fila
readLines('carseats.tsv', n = 3)
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
readLines('carseats.tsv', n = 3)
```

Legg merke til at første rad i fila inneholder _kolonnenavn_, men denne fila er _tabulatorseparert_ (`\t` er tegn for tabulator), det er ingen tekstkvalifikator, og `.` er brukt som desimaltegn.

## Tabulatorseparerte filer (2) {.build}

Vi leser inn tabulatorseparerte filer med `read.delim()`:

```{r, eval=FALSE, echo=TRUE}
df <- read.delim('carseats.tsv')
print(df[1:5, 1:8])
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
df <- read.delim('carseats.tsv')
print(df[1:5, 1:8])
```

## Tekstkoding {.flexbox .vleft}

Et vanlig problem med innlesning av data, er å håndtere norske tegn (ikke-ASCII). Ofte er det tekstkodingen som er årsaken.

Løsninger:

* Tekstkodingen kan angis med agumentene `fileEncoding` og `encoding` (varierer litt etter funksjon): `CP1252` er vanlig på Windows, mens `UTF-8` er vanlig på macOS og web (for det meste)
* **Hvis du kan velge tekstkoding på rådata, velg alltid UTF-8**

## Oppgaver {.flexbox .vleft}

**Husk at du kan bruke `?read.csv` for å få informasjon om funksjonen!**

1. Les inn fila `carseats.csv` som `carseats` med `read.csv()`
2. Bruk `head()` for å se de første observasjonene og `tail()` for å se de siste observasjonene
3. Bruk `sum()` og `mean()` for å finne sum og gjennomsnitt på variablene `Sales` og `Price`
4. Les inn fila på nytt, men bruk argumentet `stringsAsFactors` og sett dette til `TRUE`. Ser du en forskjell i hvordan fila er lest inn (hint: bruk for eksempel funksjonen `str()`)

## readxl {.flexbox .vleft}

To viktige funksjoner:

* `excel_sheets` og
* `read_excel`

`read_excel()` støtter både `xlsx` og `xls`-filer, og vil gjette type basert på filnavn.

Hvis du vet hvilket format du skal lese, kan du bruke `read_xls()` eller `read_xlsx()`

## readxl {.flexbox .vleft .extraspace}

* Du kan endre hvilket _ark_ som skal leses inn med argumentet `sheet`
* Du kan bruke funksjonen `excel_sheets()` for å finne ut at hvilke ark som finnes i en fil
* Du kan endre hvilket _område_ som leses inn med argumentet `range` (bruker standard cellereferanser i Excel, slik som `'A2:C20'`)

```{r, eval=FALSE, echo=TRUE}
# Eksempel
read_excel('carseats.xlsx', sheet = 'Sheet1', range = 'A1:G20')
```


## Les inn data fra Stata

Vi kan lese inn data fra Stata med pakken `heaven`.

```{r, eval=FALSE, echo=TRUE}
library(haven)
df <- read_dta('kompensasjonsordning.dta')
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE}
setwd(sprintf('%s/course-material/statistikk-med-r/', here::here()))
library(haven)
komp_ordning <- read_dta('kompensasjonsordning.dta')
head(komp_ordning)
```

## Oppgaver {.flexbox .vleft .extraspace}

1. Last inn pakken `readxl` med `library(readxl)`
2. Les inn fila `carseats.xlsx` som `carseats_excel` med `read_xlsx` fra pakken `readxl`
3. Bruk `summary` på `carseats_excel`. Hva er median for variabelen `Price`?
4. Les inn fila `carseats.xlsx` på nytt, men kun med de 30 første radene med data og de 5 første kolonnene i Excel-fila

# Deskriptiv statistikk

## Deskriptiv statistikk {.flexbox .vleft .extraspace}

1. **Beskrive data** 
    + basefunksjoner i R
2. **Visualisere data**
    + basefunksjoner i R og pakken `ggplot2`
3. **(Mild introduksjon til) datavasking**


**Noen nevnbare pakker som ikke dekkes**

* `dplyr` og `tidyverse`
* `data.table`

# Beskrive data

## Repetisjon av noen funksjoner {.flexbox .vleft}

* `dim()` : dimensjoner i datasettet
* `nrow()` og `ncol()` : antall rader og kolonner
* `str()` : struktur
* `head()`: øverste del av datasett
* `tail()`: nederste del av datasett

## Enveis og toveis tabeller  {.flexbox .vleft}

* `table(x, ...)` 
* `aggregate(x, by, FUN)`

```{r, echo=FALSE, eval=FALSE}

table(x, ...,          # Data
      useNA = 'ifany'  # Inkludering av missing  
      )

aggregate(x,           # Data
          by,          # Liste over grupperingsvariabler
          FUN          # Funksjon som skal brukes
          )
```


## Enveis og toveis tabeller - table()

```{r, echo=FALSE, eval=FALSE}

table(x, ...,          # Data
      useNA = 'ifany'  # Inkludering av missing  
      )
```

```{r, echo=FALSE}
carseats <- ISLR::Carseats
carseats$Urban[35:44] <- NA
```

```{r, echo=TRUE, eval=TRUE}
# Frekvenstabell over antall Urbane lokasjoner
table(carseats$Urban)
```

```{r, echo=TRUE, eval=TRUE}
# Inkluder missing
table(carseats$Urban, useNA = 'ifany')
```

## Enveis og toveis tabeller - table()

```{r, echo=TRUE, eval=TRUE}
# Lage et tabellobjekt 
tbl <- table(carseats$Urban, carseats$ShelveLoc)

# Bruker proportions() med margin = 1 for andeler fordelt på radene
proportions(tbl, margin = 1)
```

```{r, echo=FALSE}
carseats <- ISLR::Carseats
```


## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=FALSE}

aggregate(x,           # Data frame
          by,          # Liste over grupperingsvariabler
          FUN          # Funksjon som skal brukes
          )
```

* Aggregere verdier i en data frame
* Output er en data frame

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE}
# Vi aggregerer gjennomsnittlig salg fordelt på Urban 
#  og ShelveLoc (kvalitet på hylleplassering)
aggregate(carseats$Sales, 
          by = list(UrbanLoc = carseats$Urban, Hylleplassering = carseats$ShelveLoc), 
          FUN = mean, na.rm=TRUE)
```

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE}
# Vi kan også lage en ny aggregert data frame
agg_salg <- aggregate(carseats$Sales, 
                      list(UrbanLoc = carseats$Urban, 
                           Hylleplassering = carseats$ShelveLoc), 
                      mean, na.rm = TRUE)

colnames(agg_salg)[colnames(agg_salg) == 'x'] <- 'Snitt_Salg'
head(agg_salg)
```

## Enveis og toveis tabeller - aggregate()

```{r, echo=TRUE, eval=TRUE, warning=FALSE}
# Også mulig å aggregere på hele datasettet
aggregate(carseats, list(UrbanLoc = carseats$Urban), mean, na.rm=TRUE)
```

## Sentraltendens og spredning {.flexbox .vleft}

Vennlig påminnelse om målenivå

+---------------+---------------+----------------+-----------+
| Type data     | Målenivå      | Sentraltendens | Spredning |
+===============+===============+================+===========+
| Kategoriske   | Nominal       | Modus          | Ingen     |
|               |               |                |           |
|               | Ordinal       | Modus, median  | IQR       |
|               |               |                |           |   
+---------------+---------------+----------------+-----------+
| Kontinuerlige | Intervall/    | Modus          | Range     |
|               |               |                |           |
|               | Forholdstall  | Median         | Varians   |
|               |               |                |           |
|               |               | Gjennomsnitt   | Std.dev   |
|               |               |                |           |
|               |               |                | IQR       |
+---------------+---------------+----------------+-----------+

## `summary()`

```{r, echo=TRUE, eval=TRUE}
# Data frame summary, her utvalgte kolonner
summary(carseats[, 1:4])

# En kolonne i en dataframe
summary(carseats$Price)

```

## `summary()`

```{r, echo=TRUE, eval=TRUE}
# En vektor
pris <- carseats$Price
summary(pris)
```

## Sentraltendens

```{r, echo=TRUE, eval=TRUE}

# Median
median(carseats$Price)

# Gjennomsnitt
mean(carseats$Price)

```

## Sentraltendens

Husk argumentet `na.rm`!
```{r, echo=TRUE, eval=TRUE}
# En vektor hvor minst én verdi er missing
x <- c(1:15, NA, 17:20)
```

```{r, echo=TRUE, eval=TRUE}
mean(x)

mean(x, na.rm = TRUE)

```

## Spredning

```{r, echo=TRUE, eval=TRUE}
# range() printer min- og maksverdier
range(carseats$Price)

# Funksjonen diff kombinert med range() gir variasjonsbredden
diff(range(carseats$Price))

# Dette er det samme som 
max(carseats$Price)-min(carseats$Price)

```

## Spredning

```{r, echo=TRUE, eval=TRUE}
# Finne kvartiler/persentiler
quantile(carseats$Price, probs = c(0.25, 0.50, 0.75))

# Finn kvartilbredde med IQR (Avstand mellom Q1 Q3)
IQR(carseats$Price)

# Standardavvik
sd(carseats$Price)

```


## Oversikt over noen funksjoner

+-------------------------+-------------------------------------+
| Funksjon                | Beskrivelse                         |
+=========================+=====================================+
| summary(x)              | Oppsummerende deskriptiv statistikk |
+-------------------------+-------------------------------------+
| min(x), max(x)          | Min- og maksverdier                 |                   |
+-------------------------+-------------------------------------+
| mean(x), median(x)      | Gjennomsnitt og median              |
+-------------------------+-------------------------------------+
| diff(range(x))          | Variasjonsbredde                    |
+-------------------------+-------------------------------------+
| IQR(x)                  | Kvartilbredde (avstand Q1 og Q3)    |          |
+-------------------------+-------------------------------------+
| quantile(x)             | Kvartiler/persentiler               |
+-------------------------+-------------------------------------+
| sd(x)                   | Standardavvik                       |                 
+-------------------------+-------------------------------------+

## Oppgaver - Deskriptiv statistikk {.flexbox .vleft .extraspace}

Les inn datasettet `komp_oppg.RDS` med `readRDS('komp_oppg.RDS')`

1. Lag en frekvenstabell basert på `sektorkode`.
2. Bruk `aggregate()` og `sum()` til å summere `belop` fordelt på `sektorkode`.
3. Finn median og gjennomsnitt til variabelen `belop`. Tolk.
4. Bruk `quantile()`-funksjonen til å printe ut 25te, 75te og 90nde persentil. Sammenlign med `min()` og `max()`.
5. Finn IQR uten å bruke funksjonen IQR basert på tallene over.
   + Får du det samme tallet med funksjonen `IQR()`?

## Visualisere - base R {.flexbox .vleft}

* `hist(x, ...)`
* `boxplot(x, ...)`
* `plot(x, y, ...)`

```{r, echo=FALSE, eval=FALSE}

# Histogram
hist(x, 
     breaks = n,
     freq = TRUE,
     main = "Tittel", 
     ...)

# Boxplot
boxplot(x, ...)

boxplot(x1~x2,
        data = df, 
        ...)

```

## Histogram {.flexbox .vleft .small-code}

```{r, echo=TRUE, eval=FALSE}
hist(carseats$Sales)
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
hist(carseats$Sales)
```

## Histogram {.small-code}

```{r, echo=TRUE, eval=FALSE}
# Endre antallet intervaller (bins/breaks)
hist(carseats$Sales, breaks = 15)
```

```{r, echo=FALSE, eval=TRUE}
# Endre antallet intervaller (bins/breaks)
par(bg = 'transparent')
hist(carseats$Sales, breaks = 15)
```

## Histogram {.small-code}
```{r, echo=TRUE, eval=FALSE}
# Endre fra frekvenser til 'density'
hist(carseats$Sales, freq = FALSE)
```

```{r, echo=FALSE, eval=TRUE}
# Endre fra frekvenser til 'density'
par(bg = 'transparent')
hist(carseats$Sales, freq = FALSE)
```

## Histogram {.small-code}
```{r, echo=TRUE, eval=FALSE}
hist(carseats$Sales, main = "Antall solgte bilseter (1000)")
rug(carseats$Sales, main = "Antall solgte bilseter (1000)")
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
hist(carseats$Sales, main = "Antall solgte bilseter (1000)")
rug(carseats$Sales, main = "Antall solgte bilseter (1000)")
```

## Data skew(ed) - what to do? {.small-code}

```{r, echo=FALSE, eval=TRUE}
komp_oppg <- readRDS(sprintf('%s/course-material/statistikk-med-r/komp_oppg.RDS', here::here()))
fb_venner <- komp_oppg$omsetning_sp/1000
```

```{r, echo=TRUE, eval=FALSE, warning = FALSE, message = FALSE}
# Hva hvis fordelingen var veldig skjev?
hist(fb_venner, breaks = 15)
rug(fb_venner, breaks = 15)
```

```{r, echo=FALSE, eval=TRUE, warning = FALSE, message = FALSE}
# Hva hvis fordelingen var veldig skjev?
par(bg = 'transparent')
hist(fb_venner, breaks = 15)
rug(fb_venner, breaks = 15)
```

## Data skew(ed) - what to do? {.small-code}

```{r, echo=TRUE, eval=FALSE, warning = FALSE, message = FALSE}
# En løsning er å logtransformere data
hist(log10(fb_venner), breaks = 15)
rug(log10(fb_venner), breaks = 15)
```

```{r, echo=FALSE, eval=TRUE, warning = FALSE, message = FALSE}
# En løsning er å logtransformere data
par(bg = 'transparent')
hist(log10(fb_venner), breaks = 15)
rug(log10(fb_venner), breaks = 15)
```

## Data skew(ed) - what to do? {.small-code}

```{r, echo=TRUE, eval=TRUE, warning = FALSE, message = FALSE}
10^(c(2, 4, 4.5))
```
```{r, echo=FALSE, eval=TRUE, warning = FALSE, message = FALSE}
# En løsning er å logtransformere data
par(bg = 'transparent')
hist(log10(fb_venner), breaks = 15)
rug(log10(fb_venner), breaks = 15)
```


## Boxplot {.small-code}

```{r, echo=TRUE, eval=FALSE}
boxplot(carseats$Sales)
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
boxplot(carseats$Sales)
```

## Boxplot {.small-code}

```{r, echo=TRUE, eval=TRUE, fig.show='hide'}
boxplot(carseats$Sales)$stats[, 1]   # Boxplot.stats viser hvilke verdier som boxplottet er basert på

quantile(carseats$Sales)             # Under the hood ca de samme verdiene som persentilene fra i stad

IQR(carseats$Sales)                  # Kvartilbredden - Q3(9.32)-Q1(5.38)

IQR(carseats$Sales)*1.5 + 9.32       # Uteligger = obs IQR*1.5 fra 75te persentil

```

## Boxplot {.small-code}

```{r, echo=TRUE, eval=FALSE}
boxplot(Sales~ShelveLoc, data = carseats)
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
boxplot(Sales~ShelveLoc, data = carseats)
```


## Boxplot {.small-code}

```{r, echo=TRUE, eval=FALSE}
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue")
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue")
```

## Boxplot {.small-code}

```{r, echo=TRUE, eval=FALSE}
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue", 
        main = "Salg fordelt på hylleplassering")
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
boxplot(Sales~ShelveLoc, data = carseats, col = "steelblue")
```

## Plot {.small-code}

```{r, echo=TRUE, eval=FALSE}
plot(carseats$Sales, carseats$Price)
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
plot(carseats$Sales, carseats$Price)
```

## Plot {.small-code}

```{r, echo=TRUE, eval=FALSE}
plot(carseats$Sales, carseats$Price, 
     panel.first = lines(stats::lowess(carseats$Sales, carseats$Price)))
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
plot(carseats$Sales, carseats$Price, 
     panel.first = lines(stats::lowess(carseats$Sales, carseats$Price)))
```


## Plot {.small-code}

```{r, echo=TRUE, eval=FALSE}
plot(carseats$Sales, carseats$Price, 
     panel.first = lines(stats::lowess(carseats$Sales, carseats$Price)),
     xlab = "Sales", ylab = "Price")
```

```{r, echo=FALSE, eval=TRUE}
par(bg = 'transparent')
plot(carseats$Sales, carseats$Price, 
     panel.first = lines(stats::lowess(carseats$Sales, carseats$Price)),
     xlab = "Sales", ylab = "Price")
```


## Oppgaver - Visualisering {.flexbox .vleft .extraspace}

Les inn datasettet `komp_oppgave.RDS` med `readRDS('komp_oppg.RDS')`.

1. Lag en variabel `belop_1000` som viser beløp i 1000 kroner
2. Lag et histogram av `belop_1000` og bruk funksjonen `rug()` rett etterpå 
    + Hvordan vil du beskrive fordelingen?
    + Hva kan du gjøre med variabelen for å visualisere data bedre?
    + Lag histogrammet på nytt
3. Lag et boxplot med `belop_1000` fordelt på `sektorkode`
    + Hvordan kan du forbedre boxplottet?
    + Lag boxplottet på nytt


# (Mild introduksjon til) datavasking
## Data er ofte _dirty_ {.flexbox .vleft}

Menneskelige og tekniske feil fører til _dirty data_

* Datavasking er noe av det viktigste vi gjør
* Bli godt kjent med egne data
* Planlegg god tid til datavasking

## Dirty data - vanlige sjekker {.flexbox .vleft}

* Missing data 
* Datatype
* Range
* Duplikater
* Samsvar på tvers
* Tekstvariabler


## Missing data - et uunngåelig problem {.flexbox .vleft .extraspace}

+-------------------------------+----------------------------------------+-------------------------+
| Type missing data             | Beskrivelse                            | Eksempel                |
+===============================+========================================+=========================+
| Helt tilfeldig                | Ingen sammenheng med andre observerte/ | Feil på blodtrykksmåler |
|                               |  uobserverte verdier                   | i blodtrykksstudie      |
| _Missing completely at random_|                                        |                         |
+-------------------------------+----------------------------------------+-------------------------+
| Betinget tilfeldig            | Sammenheng med andre _observerte_      | Yngre møter opp         |
|                               | verdier                                | sjeldnere enn eldre     |  
| _Missing at random_           |                                        |                         |
+-------------------------------+----------------------------------------+-------------------------+
| Ikke-tilfeldig                | Sammenheng med andre _uobserverte_     | Eldre med høyt blodtrykk|
|                               | verdier                                | møter sjeldnere enn     |  
| _Missing not at random_       |                                        | andre eldre             |
+-------------------------------+----------------------------------------+-------------------------+

## Håndtering av missing data {.flexbox .vleft .extraspace}

* **Droppe observasjoner**
* **Imputere (fylle inn verdier)** basert på
    + statistiske mål (gjennomsnitt, median)
    + kjennskap til dataene
    + algoritmer/maskinlæring

* **Løsningen avhenger av**
    + hvor godt du kjenner data
    + type missing du antar at du har

## Missing data - funksjoner i R 

* Missingverdier i R: `NA`, `NaN` 
* Vit hvilke eventuelle andre verdier i ditt datasett som er missing (eks. 99, 0)

```{r, eval=TRUE, echo=TRUE}
# Missing
is.na(c(NA, NaN)) 

# Ikke missing
is.na(0)

```

## Missing data - funksjoner i R 
```{r, eval=TRUE, echo=TRUE}
alder <- c(27, 40, 34, 25, 57, 45, 87, NA, 38, NA, 90)

# Elementvis test for missing i vektor alder
is.na(alder)

# Test for om alder inneholder missingverdier
anyNA(alder)

```


## Missing data - funksjoner i R 

```{r, eval=TRUE, echo=TRUE}
# Hovedregel: NA + noe = NA
mean(alder)

# Fjern missingverdier når funksjonen kjøres
mean(alder, na.rm = TRUE)

# Fjern missingverdier fra alder
na.omit(alder)

```

## Missing data - funksjoner i R 
```{r, eval=TRUE, echo=TRUE}
# Missingverdier i en data frame
data("airquality")
anyNA(airquality)

# Antall verdier missing
sum(is.na(airquality))

```

## Missing data - funksjoner i R 

```{r, eval=TRUE, echo=TRUE}
# Per kolonne i et datasett med sapply
sapply(airquality, anyNA)

# Per kolonne i et datasett med lapply
unlist(lapply(airquality, function(x) sum(is.na(x))))

```

## Missing data - visualisering

```{r, eval=TRUE, echo=TRUE}
naniar::vis_miss(airquality)
```

## Videre med datavasking

```{r, eval=TRUE, echo=FALSE}
dato <- c('01/03/2020', '01/04/2020', '01/05/2020', '01/06/2020', '01/07/2020', '01/08/2020', '01/09/2020', '01/10/2020','01/11/2020','01/12/2020')
hk <- data.frame(
  navn = c(rep('Ove', 10), rep('Eivor', 10), rep('Lars', 10)),
  alder = c(rep(36, 10) , rep(34, 8), NA ,NA, rep(29, 8), NA, 58),
  dato = rep(dato, 3),
  stemning = c('OK', 'Glad', 'Superglad', 'Glad', 'Langt nede','Nede', 'Superglad', 'Langt nede','OK', 'Glad', 'Nede','Nede', 'Superglad', 'Langt nede','Glad', 'Langt nede', 'Glad', 'Langt nede','Nede', 'Superglad', 'Langt nede', 'OK', 'Superglad', 'Glad', 'nede','nede', 'Glad', 'OK', 'Ok', 'langt nede')
)

hk <- rbind(hk, hk[rep(1,5),])
hk$dato[13] <- '01/05/2023'
```

Et eksempeldatasett: Humøret til Ove, Eivor og Lars i perioden 01.03.2020-01.12.2020

```{r, eval=TRUE, echo=TRUE}
str(hk)
```

## Datatype
```{r, eval=TRUE, echo=TRUE}
# Sjekker datatypen til dato
class(hk$dato)

# Ser på noen av verdiene
hk$dato[1:5]

```

## En kort tur innom håndtering av datoer {.flexbox .vleft}

Vi må fortelle R hvilket format datostrengene har

* `?strptime` for oversikt over formatangivelser
* `as.Date(x, format)` for å konvertere til dato
* `as.POSIXct(x, format)` for å konvertere til datetime

## En kort tur innom håndtering av datoer {.flexbox .vleft}

| Tekstdato                 | Format               |       
| --------------------------|:--------------------:|
| "01/03/2020"              | `%d/%m/%Y`           |
| "20200301"                | `%Y%m%d`             |
| "1. mar 2020"             | `%d. %b %Y`          |
| "1. mars 2020 15:17:23"   | `%d. %B %Y %H:%M:%S` |
| "01-03-20 14:14"          | `%d-%m-%y %H:%M`     | 

## En kort tur innom håndtering av datoer

```{r, eval=TRUE, echo=TRUE}
# Konvertere til dato med as.Date() 
as.Date('01.03.2020', format = "%d.%m.%Y")

# Konverterer til datetime med as.POSIXct()
as.POSIXct('01.03.2020 13:09', format = "%d.%m.%Y %H:%M")

```

## Datatype
```{r, eval=TRUE, echo=TRUE}
# hk$dato[1:3]
hk$dato2 <- as.Date(hk$dato, format = '%d/%m/%Y')
hk$dato2 [1:5]

# Sjekker datatype
class(hk$dato2)
```

## Range-problematikk
```{r, eval=TRUE, echo=TRUE}
# Faller alle verdiene innenfor riktig intervall?
range(hk$dato2)

# Finner observasjonen(e) med dato lengre fram i tid enn 01.12.2020
which(hk$dato2 > as.Date('2020-12-01'))
```

## Range-problematikk
```{r, eval=TRUE, echo=TRUE}
# Ser på denne observasjonen
hk[13,]

```

```{r, eval=TRUE, echo=TRUE}
# I dette tilfellet endre til det som sannsynligvis er den riktige datoen
hk$dato2[13] <- as.Date('2020-05-01')
```

## Duplikater {.flexbox .vleft .extraspace}

Kjenn observasjonsenheten
 
Nyttige funksjoner

* `unique()`
* `length()`
* `duplicated()`
* `table()`

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Printer ut unike verdier i en vektor
unique(hk$navn)

# Antall unike verdier i en vektor
length(unique(hk$navn))
```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Sjekker om navnekolonnen har duplikater
duplicated(hk$navn)

# Antall duplikater for navn
table(duplicated(hk$navn))
```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Vi kan sjekke for fulle duplikater
table(duplicated(hk))

# Ser på de duplikate radene
hk[duplicated(hk), ]

```

## Duplikater

```{r, eval=TRUE, echo=TRUE}
# Lager et nytt datasett uten duplikater
hk_vasket <- hk[!duplicated(hk),]

# Sjekker at det ikke er noen duplikater
table(duplicated(hk_vasket))
```

## Tekstvariabler

| Beskrivelse                                       | Funksjon(er)         |       
| --------------------------------------------------|:--------------------:|
| Slå sammen tekststrenger                          | `paste`, `paste0`    |
| Fjern mellomrom fra starten/slutten av en streng  | `trimws`             |
| Finn antall tegn i en tekststreng                 | `nchar`              |
| Split elementer i en tekststreng                  | `strsplit`           |
| Konverter en streng til store/små bokstaver       | `toupper`, `tolower` | 
| Hent ut eller erstatt deler av en tekststreng     | `substr`, `substring`|

## Tekstvariabler

```{r, eval=TRUE, echo=TRUE}
# Unike verdier av stemning-variabelen
unique(hk_vasket$stemning)

# Konverterer til små bokstaver
hk_vasket$stemning <- tolower(hk_vasket$stemning) %>% trimws()
unique(hk_vasket$stemning)
```

## Regulære uttrykk {.flexbox .vleft .extrapace}

* **Regulære uttrykk** er en nyttig metode for å finne og behandle ulike *mønstre* i tekststrenger 

* Kan brukes på tvers av en rekke ulike programmeringsspråk 

* For en interaktiv innføring gå til [regex101.com](https://regex101.com/)

* Se [Regular Expressions as used in R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html) 
for en oversikt over regulære uttrykk i R

* Vi legger ved fjorårets slides om regulære uttrykk


## Oppgaver {.flexbox .vleft}

Les inn datasettet `komp_oppgave.RDS` med `readRDS('komp_oppgave.RDS')`

1. Hvilke kolonner i `komp_oppgave` har missingverdier?
2. Lag en ny kolonne som konverterer `stiftelsesdato` til dato
    + sjekk at den nye kolonnen har datatype `Date`
3. Gjør oppgave 1 på nytt
4. Finnes det duplikater i datasettet?
5. Hvor mange unike verdier har kolonnene `stiftelsesdato` og `navn`?

# Regresjonsbaserte modeller

## Lineære modeller {.flexbox .vleft}

$$Y=\alpha+\beta x+\epsilon$$

Hvor $\alpha$ er konstantleddet, $\beta$ er helningen og $\epsilon$ er feilleddet.

**NB!** I disse slidene vil vi bruke uttrykket _avhengig variabel_ for $Y$ og _uavhengige variabler_ for $x$. I dokumentasjon for R kalles disse som regel _response_ og _predictors_.

## Formelobjektet {.flexbox .vleft}

* Modellfunksjonene i R bruker et spesielt _formelobjekt_
* Formelobjektet spesifiseres ved å bruke tegnet `~` i formen `y ~ x`
* Formelobjektet kan brukes både for å bygge additive modeller, og for å legge til transformasjoner eller samspillsledd
* Når du bruker formelobjektet med en data frame, holder det å spesifisere kolonnenavnene i formelen

## Kategoriske variabler (factor) {.flexbox .vleft}

* R håndterer kategoriske variabler med datatypen `factor`
* R leser nå alle tekstkolonner som `character`, men dette kan endres til `factor` ved å sette argumentet `stringsAsFactors` til `TRUE`
* Tekstvariabler (og numeriske variabler) kan også kodes om til faktorer med funksjonen `factor()`
* Faktorvariabler kan brukes direkte i regresjonsmodeller _uten_ omkoding (det opprettes automatisk k-1 dummyvariabler)
* Vi kan se dummyvariablene R oppretter med funksjonen `contrasts()`

## Enkel regresjonsmodell {.flexbox .vleft}

* Vi kan bruke den innebygde funksjonen `lm()` for å lage en regresjonsmodell
* Vi bruker formelobjektet for å spesifisere modellen
* Hvis vi kjører funksjonen direkte, får vi ut koeffisientene til modellen
* Vi kan også lagre modellen til et eget objekt som vi kan jobbe videre med
* Funksjonen `summary()` benyttes for å få en oppsummering av modellen og dens tilpasning til data
* `lm()`gir ikke standardiserte koeffisienter; dette løses ved å standardisere variablene først med `scale()` eller bruke pakken `lm.beta`

## Enkel regresjonsmodell (2) {.build}

For disse eksemplene bruker vi datasettet `Boston` fra pakken `MASS`

```{r, echo=TRUE, eval=TRUE}
library(MASS)
data('Boston')
```

Vi bygger en modell for å estimere median husverdi `medv` i ulike bydeler i Boston (se `?Boston` for detaljer).

```{r, echo=TRUE, eval=TRUE}
summary(Boston$medv)
```

## Enkel regresjonsmodell (3) {.small-code}

```{r, echo=TRUE, eval=TRUE}
library(MASS)
lm.mod <- lm(medv ~ crim, data = Boston)
summary(lm.mod)
```

## 

Vi kan hente ut koeffisientene fra modellen med `coef()` og konfidensintervallene for hver koeffisient med `confint()`

```{r, echo=TRUE}
coef(lm.mod)
confint(lm.mod)
```

##

Vi kan hente ut estimert verdi på avhengig variabel med `predict()`. Ved å bruke argumentet `interval` og sette dette til `'confidence'` får vi også ut konfidensintervallene for estimatene.

```{r, echo=TRUE}
mod.preds <- predict(lm.mod, Boston, interval='confidence')
head(mod.preds)
```

## Hvor godt passer modellen til data?

| Mål                                | Forklaring |
|------------------------------------|------------|
| Residual standard error (RSE)*     | Avvik fra regresjonslinjen |
| Root mean standard deviation (RMSE)| Avvik fra regresjonslinjen |
| R<sup>2</sup>*                     | Forklart varians (standardisert fra 0 til 1) |
| F-statistic *                      | Test for om alle variabler er lik 0 |

Mål merket med * oppgis som standard av `summary()`

## {.build}

La oss se på modellen igjen:

```
Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) 24.03311    0.40914   58.74   <2e-16 ***
crim        -0.41519    0.04389   -9.46   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 8.484 on 504 degrees of freedom
Multiple R-squared:  0.1508,	Adjusted R-squared:  0.1491 
F-statistic: 89.49 on 1 and 504 DF,  p-value: < 2.2e-16
```

Modellen er signifikant, men den forklarer lite a variasjonen i `medv` og det er relativt store avvik fra regresjonslinjen.

##

Dette ser vi også i følgende plot:

```{r, eval=FALSE, echo=TRUE}
plot(crim ~ medv, data = Boston)
abline(coef(lm.mod), col = 'red', lwd = 2)
```


```{r, eval=TRUE, echo=FALSE}
par(bg='transparent')
plot(crim ~ medv, data = Boston)
abline(coef(lm.mod), col = 'red', lwd = 2)
```


## Multivariat regresjonsmodell {.flexbox .vleft}

$$Y=\alpha+\beta_1x_1+\beta_2x_2...\beta_nx_n+\epsilon$$

* Styrken med regresjonsmodellen, er at vi kan kontrollere for *mer enn én* uavhengig variabel
* I R kan bygge en multivariat regresjonsmodell ved å utvide formelobjektet
* For en vanlig additiv modell, bruker vi `+` for å legge til uavhengige variabler i modellen
* Vi kan også bruke modellobjektet til å introdusere samspill, høyere grads ledd og transformasjoner
* Hvis vi vil inkludere _alle_ variabler i modellen kan vi forkorte formelen til `y ~ .`

## 

```{r, eval=TRUE, echo=FALSE}
options(digits=10)
mult.mod <- lm(medv ~ ., data = Boston)
```

```{r, eval=FALSE, echo=TRUE}
mult.mod <- lm(medv ~ ., data = Boston)
summary(mult.mod)
```

```
Call:
lm(formula = medv ~ ., data = Boston)

Residuals:
    Min      1Q  Median      3Q     Max 
-15.595  -2.730  -0.518   1.777  26.199 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  3.646e+01  5.103e+00   7.144 3.28e-12 ***
crim        -1.080e-01  3.286e-02  -3.287 0.001087 ** 
zn           4.642e-02  1.373e-02   3.382 0.000778 ***
indus        2.056e-02  6.150e-02   0.334 0.738288    
chas         2.687e+00  8.616e-01   3.118 0.001925 ** 
nox         -1.777e+01  3.820e+00  -4.651 4.25e-06 ***
rm           3.810e+00  4.179e-01   9.116  < 2e-16 ***
```

## 

```{r, eval=FALSE, echo=TRUE}
mult.mod <- lm(medv ~ ., data = Boston)
summary(mult.mod)
```

```
age          6.922e-04  1.321e-02   0.052 0.958229    
dis         -1.476e+00  1.995e-01  -7.398 6.01e-13 ***
rad          3.060e-01  6.635e-02   4.613 5.07e-06 ***
tax         -1.233e-02  3.760e-03  -3.280 0.001112 ** 
ptratio     -9.527e-01  1.308e-01  -7.283 1.31e-12 ***
black        9.312e-03  2.686e-03   3.467 0.000573 ***
lstat       -5.248e-01  5.072e-02 -10.347  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 4.745 on 492 degrees of freedom
Multiple R-squared:  0.7406,	Adjusted R-squared:  0.7338 
F-statistic: 108.1 on 13 and 492 DF,  p-value: < 2.2e-16
```

## Oppdatere modeller med `update()` {.small-code}

```{r, echo=TRUE}
# Legger til lstat fra vår bivariate modell
mult.mod <- update(lm.mod, ~ . +lstat)
summary(mult.mod)
```

## Samspill med `:` {.small-code}

```{r, echo=TRUE}
# Modell med samspill
samspill.mod <- lm(medv ~ lstat + age + lstat:age, data = Boston)
summary(samspill.mod)
```

## Samspill med `*` {.small-code}

```{r, echo=TRUE}
# Dette gir samme resultat, men er kortere å skrive
samspill.mod <- lm(medv ~ lstat * age, data = Boston)
summary(samspill.mod)
```

## Annengradsledd med `I(x^2)` {.small-code}

```{r, echo=TRUE}
trans.mod <- lm(medv ~ lstat + I(lstat^2), data = Boston)
summary(trans.mod)
```

## Høyere grads ledd (polynomer) med `poly()` {.small-code}

```{r, echo=TRUE}
trans.mod2 <- lm(medv ~ poly(lstat, 4), data = Boston)
summary(trans.mod2)
```

## Logtransformering med `log(x)` {.small-code}

```{r, echo=TRUE}
trans.mod3 <- lm(medv ~ log(rm), data = Boston)
summary(trans.mod3)
```

## Standardisering {.flexbox .vleft}

* Det er ofte god praksis å standardisere variabler i en analyse for å håndtere ulike måleenheter
* Med standardisering, skaleres variablene slik at de har et gjennomsnitt på 0 og et standardavvik på 1
* Standardiserte variabler gjør det lettere å tolke koeffisientene i regresjonsanalysene (R rapporterer ikke betakoeffisienter som standard), og andre modeller er sensitive for ulike måleenheter
* I R kan vi standardisere variabler med funksjonen `scale()`

```{r, echo=TRUE}
lstat <- Boston$lstat
### <b>
lstat.scaled <- scale(lstat)
### </b>
```

## Log-lineære modeller {.flexbox .vleft}

* For data hvor vi har en dikotom/binær avhengig variabel, så egner den lineære modellen seg dårlig
* I R bruker vi funksjonen `glm()` (generalized linear models) for å bygge en logistisk regresjonsmodell
* `glm()` støtter en rekke modeller, inkludert logistisk gjennom argumentet `familiy`
* `glm()` kan også brukes til vanlige lineære modeller slik som med `lm()`

## Log-lineære modeller (2) {.small-code}

```{r, eval=TRUE, echo=FALSE}
Default <- ISLR::Default
```

```{r, eval=TRUE, echo=TRUE}
logit.mod <- glm(default ~ balance, data = Default, family = binomial)
summary(logit.mod)
```

## Oppgaver

```{r, eval=FALSE, echo=TRUE}
carseats <- read.csv('carseats.csv', stringsAsFactors = TRUE)
```

```{r, eval=TRUE, echo=FALSE}
carseats <- read.csv(
  sprintf('%s/course-material/statistikk-med-r/carseats.csv', here::here()),
  stringsAsFactors = TRUE)
```

1. Lag en regresjonsmodell med `Sales` som avhengig variabel. Inkluder _alle_ andre variabler som uavhengige variabler. Tilordne modellen til `car.mod1`
2. Hva er justert $R^2$ for modellen?
3. Hvilke variabler i modellen er ikke signifikante?
4. Bygg en ny modell, enten med å bruke `lm()` på nytt, eller med `update()`, men uten variablene som ikke var signifikante (hint: husk at faktorvariabler håndteres på en spesiell måte i modeller). Tilordne modellen til `car.mod2`
5. Sammenlign F-statistikken og $R^2$ i den nye modellen med den gamle. Har modellen blitt bedre eller dårligere med de utelatte variablene?

# Statistisk læring

## Predikere nye data

> - Til nå har vi analysert data for å finne sammenhenger mellom _uavhengige_ variabler på _avhengig_ variabel
> - Noen ganger står vi overfor et problem hvor vi ønsker å predikere nye observasjoner fra tidligere data
> - Dette er det grunnleggende problemet innenfor veiledet (supervised) maskinlæring
> - For _nye_ data er ikke verdien på responsvariablen kjent (vår tidligere avhengige variabel)
> - Vi kan dele inn i to typer problem: regresjonsproblem og klassifiseringsproblem
> - Vi trener en modell på data med kjente verdier på responsvariabelen, og bruker denne på nye data
> - `predict()`-funksjonen i R kan også benyttes til dette

## Fremgangsmåte {.flexbox .vleft}

> 1. Splitte datasettet tilfeldig i et _treningsdatasett_ og et _testdatasett_
> 2. Bygge en modell på _treningsdatasettet_
> 3. Estimere verdier på _testdatasettet_
> 4. Evaluere modellens på _testdatasettet_

##

```{r, eval=TRUE, echo=FALSE, fig.height=6, fig.width=10}
set.seed(42)
x <- seq(0, 1, .01)
x <- sample(x, 600, TRUE) + rnorm(600, .2, .1)
y <- 3 + 3*x + 120*x^2 + rnorm(length(x),0,40)

quadric <- lm(y ~ poly(x, 2))
sspline <- smooth.spline(x, y, df = 20)

par(bg = 'transparent')
plot(y ~ x,
     pch = 19, col = rgb(.3,.3,.3,.6),
     xlab = NA, ylab = NA, bty = 'n',
     main='Over-, under- og normal tilpasning')
abline(lm(y ~ x), col='blue', lwd=4)
lines(sspline, col='red', lwd=4)
lines(sort(x), predict(quadric, list(x = x))[order(x)], col='green', lwd=4)
```

## Splitt data i trening og test {.build}

For å splitte data i et _treningsdatasett_ og et _testdatasett_ kan vi bruke en tilfeldighetsfunksjon som `runif()`

```{r, eval=TRUE, echo=TRUE}
# Opprett observasjoner fra en uniform distribusjon
set.seed(1984)
x <- runif(nrow(Boston), 0, 1)
```

```{r, eval=TRUE, echo=TRUE}
# Lag en 70/30 splitt ved at verdier under .7 blir kodet TRUE
x <- x < .7
```

```{r, eval=TRUE, echo=TRUE}
table(x)
```

## Prediksjon på trening og testdata {.build}

Vi kan nå _trene_ en modell på treningsdata, og _evaluere_ denne på testdata:

```{r, echo=TRUE}
# Splitt data i trening og test basert på x
boston.trening <- Boston[x,]
boston.test <- Boston[!x,]
```

```{r, echo=TRUE}
# Bygg en modell på treningdata
mod <- lm(medv ~ ., data = boston.trening)
```

```{r, echo=TRUE}
# Vi bruker predict både på trenings og testdata
preds.trening <- predict(mod, boston.trening)
preds.test <- predict(mod, boston.test)
```

## Prediksjon på trening og testdata

Vi beregner RMSE ved å ta differansen mellom de estimerte og de observerte verdiene. Vi beregner RMSE både for trenings- og testdata:

```{r, echo=TRUE}
err.trening <- preds.trening - boston.trening$medv
sqrt(mean(err.trening^2))
err.test <- preds.test - boston.test$medv
sqrt(mean(err.test^2))
```

## Oppgaver {.flexbox .vleft}

1. Lag trenings- og testdata med en 70/30 splitt på `carseats`. Tilordne treningsdata til `car.train` og testdata til `car.test`. Sett seed til 42 før du bruker en funksjon som trekker fra en sannsynlighetsfordeling.
2. Bygg en modell på treningsdata med `Sales` som avhengig variabel og `CompPrice`, `Advertising`, `Price` og `ShelveLoc` som uavhengige variabler. Tilordne modellen til `train.mod`
3. Bruk `predict()` til å estimere salgsvolum på _treningsdata_. Beregn RMSE for treningsdata.*
4. Bruk `predict()` til å estimere salgsvolum på _testdata_. Beregn RMSE for testdata.*
5. Hvor godt predikerer modellen på testdata sammenlignet med treningsdata?

* Hint: RMSE kan beregnes med `sqrt(mean(error^2))` hvor `error` er en vektor med differansen mellom estimert verdi og observert verdi.