---
title: "Introduksjon til R"
author: "Ove Haugland Jakobsen og Aleksander Eilertsen"
date: "29 januar 2020"
always_allow_html: yes
output:
  ioslides_presentation:
    fig_retina: 2
    widescreen: yes
    css: ../assets/styles.min.css
    logo: ../assets/rr-logo.svg
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
set.seed(42)
```


# Hva er R?

## Hva er R? {.flexbox .vleft}

- R er et høynivå programmeringsspråk beregnet (primært) for statistikk, men med svært mange bruksområder
- R brukes innen en rekke sektorer og fagområder (inkludert Riksrevisjonen `r emo::ji('smiley')`) og er et av de viktigste verktøyene innen data science
- I utgangspunktet skjer alt arbeid i R via et terminalvindu ved å skrive inn kommandoer, men verktøy som *RStudio* og *R Commander* gjør det lettere å jobbe med R

## Hva kan R brukes til? {.flexbox .vleft}

Kortversjonen: det meste

Den (litt) lengre versjonen:

- Datahøsting og datamanipulering
- Dataanalyse og modellering, inkludert maskinlæring (kunstig intelligens)
- Datavisualisering
- Analyse av ustrukturerte data
- Webapplikasjoner (med Shiny)
- Produksjon av rapporter og dokumentasjon av analyser (med Rmarkdown)
- Denne presentasjonen

## Hva bruker vi R til i Riksrevisjonen? {.flexbox .vleft}

- Innhenting av data fra nett og via APIer (webscraping)
- Statistiske analyer og utprøving av maskinlæring
- Bearbeiding av data, blant annet fra datafangst
- Analyse og visualisering av geodata
- Utvikling av mindre webapplikasjoner (slik som Løvehulen, Rapportsøk, og Kommunekart)
- Og mye, mye, mer

## Dataanalyse i R {.flexbox .vleft .extraspace}

- Enorme muligheter for dataanalyse i R
- R håndterer både _strukturerte_ og _ustrukturerte_ data
- En rekke innebygde funksjoner for statistisk analyse, og kan utvides til de fleste analyseformål
- God støtte for datavisualiseringer, både innebygget og via utvidelser (pakker)

## Koding i R {.flexbox .vleft}

- R er primært _tekstbasert_
- Vi kan jobbe i en _konsoll_ hvor vi skriver inn kommandoer (kode) direkte, eller med et _skript_
- Vi jobber ikke direkte med filer, men med et _miljø_ (environment) som inneholder _objekter_
- _Objekter_ i R kan være tradisjonelle tabeller med data i rader og kolonner, men også variabler, innholdet på en nettside, geografiske data, eller mye mer

# Demo av RStudio

## RStudio 

```{r out.width='80%', fig.align='center'}
knitr::include_graphics('../assets/rstudio.png')
```

# Grunnleggende bruk av R 

## R som kalkulator

```{r, echo=TRUE}
# Vi kan utføre enkel aritmetikk med +, -, *, /, og ^
3 + 3  # Addisjon
3 * 3  # Multiplikasjon
3 ^ 3  # Eksponent
3 %% 3 # Modulus
```

## R som kalkulator

```{r, echo=TRUE}
3 + 3 * 3
(3 + 3) * 3
```

## Prøv selv!

# Datastrukturer i R 

# Innebygde funksjoner i R 

# Innlesing av data

## Kilder til data {.flexbox .vleft .extraspace}

* Lokale filer (semikomma- eller kommaseparerte filer, Excel, Stata)
* Databaser (SQL)
* APIer over internett (Stortingets API, SSB)
* Skytjenester (AWS, Hadoop)

## Data fra lokale filer {.flexbox .vleft}

Bruk `read.csv()` for å lese inn kommaseparerte filer, og `read.csv2()` for å lese inn semikolonseparerte filer

Excel-filer kan leses inn med funksjonen `read_excel()` fra pakken `readxl`

Vær oppmerksom på tekstkodingen til fila. På Windows benyttes formatet Windows-1252 (`CP1252`), mens det vanlige er UTF-8. *Hvis du kan velge tekstkoding på rådata, velg alltid UTF-8*

## readxl

To viktige funksjoner:

* `excel_sheets` og
* `read_excel`

`read_excel()` støtter både `xlsx` og `xls`-filer, og vil gjette type basert på filnavn. Hvis du vet hvilket format du skal lese, kan du bruke `read_xls()` eller `read_xlsx()`

## Oppgave {.flexbox .vleft .extraspace}

1. Les inn fila `carseats.csv` med `read.csv()` til objektet `carseats`
2. Bruk `head(carseats)` for å se de første observasjonene
3. Bruk `sum()` og `mean()` for å finne sum og gjennomsnitt på variablene `Sales` og `Price`

# Kontrollflyt 

## Likhet

I R kan vi teste for likhet med `==` og ulikhet med `!=`:

```{r, echo=TRUE}
TRUE == FALSE
TRUE == TRUE
FALSE != TRUE
FALSE != FALSE
```

## Likhet

```{r, echo=TRUE}
# Vi kan teste om tekst er lik
'Riksrevisjonen' == 'riksrevisjonen'
# Eller om numeriske verdier er like
16 ^ 4 == 1024 * 64
# Eller sammenligne logiske verdier med numeriske (TRUE er 1)
TRUE != 0
```


## Større og mindre enn

Vi tester om en verdi er større med `>`, større eller lik med `>=`, mindre med `<` og mindre eller lik med `<=`:

```{r, echo=TRUE}
16 ^ 4 >= 8 * 1024
```


## Større og mindre enn

Vi kan også sammenligne vektorer:

```{r, echo=TRUE}
x <- c(4, 20, 16, 34, 18, 32, 28, 31)
x > 25
x <= 20
```


## Oppgaver!

* Er uttrykket `-6 * 4 + 5` **større enn** `-3 * 8 - 4`?

## Logiske operatorer

I R bruker vi følgende logiske operatorer

* `&` for OG
* `|` for ELLER
* `!` for IKKE

## Logiske operatorer

```{r, echo=TRUE}
TRUE & TRUE
TRUE | FALSE
!FALSE
```


## Hvis

```
if (condition) {
  uttrykk
}
```

## Hvis

```
if (condition) {
  uttrykk
} else if (condition) {
  uttrykk
} else {
  
}
```

## Hvis

```{r, echo=TRUE, error=TRUE}
if (FALSE) {
  print('Sant')
}
else {
  print('Ikke sant')
}
```


## Looper

`for` og `while`

```{r, echo=TRUE}
for (x in 1:5) {
  print(paste(rep('a', x), collapse = ''))
}
```

## Apply-familien {.flexbox .vleft}

* Looper kan være praktiske, men de er også veldig _ineffektive_
* R har en serie med funksjoner som gjentar en funksjon over en `list`e eller `vector`
* `lapply` bruker en funksjon over en liste av elementer og returnerer en liste
* `sapply` er lik `lapply`, men returnerer en vektor eller matrise (alt etter hva funksjonen får som input)

## lapply

```{r, echo=TRUE}
# Opprett en liste x med 3 elementer og ta gjennomsnittet av hvert element
x <- list(a = 1:10, b = runif(10, 0, 10), c = seq(1, 28, 3))
lapply(x, mean)
```

# Egne funksjoner 

## Lag din første funksjon I 

Her definerer vi en funksjon, `square_number`, som tar et argument `n` og returnerer resultatet av dette tallet multiplisert med seg selv. 

```{r, echo=TRUE, comment='#>', collapse=TRUE}
# En funksjon for å gange et tall med seg selv 
square_number <- function(n){
  n * n  
} 
square_number(2)
square_number(16)
square_number(-4)
```


## Lag din første funksjon II 

I utgangspunktet returnerer funksjoner i R den siste kommandoen i funksjonen. Vær derfor oppmerksom på følgende: 

```{r, echo=TRUE, comment='#>', collapse=TRUE}
# NB! Denne funksjonen returnerer ikke riktig resultat.  
square_number <- function(n){
  n * n  # Dette returneres ikke 
  print(paste("Returning the square of", n)) # Dette returneres 
} 
square_number(2) 
```

## Lag din første funksjon III  

Pass derfor på at det du vil at funksjonen skal returnere står til slutt. 

```{r, echo=TRUE, comment='#>', collapse=TRUE}
square_number <- function(n){
  print(paste("Returning the square of", n))
  n * n  
} 
square_number(2)

```

## Lag din første funksjon IV  

Et alternativ er å eksplisitt opprette ett objekt som skal returneres.  

```{r, echo=TRUE, comment='#>', collapse=TRUE}
square_number <- function(n){
  out <-  n * n  # Vi definerer et objekt som skal returneres 
  print(paste("Returning the square of", n))
  out
} 
square_number(2)
```

## Bruk av Rs innebygde `return` funksjon I 

I en del tilfeller vil du se eksplisitte kall til Rs innebygde `return()` funksjon. Dette er strengt tatt ikke nødvendig når du kun vil returnere det siste objektet i en funksjon, men er en skrivemåte dere vil komme til å se. 

```{r, echo=TRUE, comment='#>', collapse=TRUE}
square_number <- function(n){
  out <-  n * n  
  print(paste("Returning the square of", n))
  return(out) 
} 
square_number(2)
```

## Bruk av Rs innebygde `return` funksjon II

Det er imidlertid viktig å merke seg at bruk av `return` vil kaste deg ut av funksjonen. Resterende kodelinjer vil derfor ikke kjøres.

```{r, echo=TRUE, comment='#>', collapse=TRUE}
# NB! Denne funksjonen returnerer ikke riktig resultat.  
# Funksjonen stopper opp når 'return' kalles. 
square_number <- function(n){
  out <-  n * n  
  return('Hello world') # Dette vil være den siste kodelinjen som funksjonen utfører
  print(paste("Returning the square of", n))
  out
} 
square_number(2)
```


## Function scoping 

Et annet viktig poeng når det gjelder funksjoner er at objekter som defineres inne i en funksjonen kun er tilgjenglig inne i funksjonen. Eksempelvis vil objektet `out` **ikke** være tilgjengelig utenfor funksjonen `square_number`.  

```{r, echo=TRUE, comment='#>', collapse=TRUE, error=TRUE}
square_number <- function(n){
  out <-  n * n  
  print(paste("Returning the square of", n))
  out
} 
out
```

## Oppgaver 

1. Lag en funksjon `power_two` som tar et argument `x` og opphøyer dette i tallet 2. 
2. Definerer et objekt `y` inne i funksjonen med resultatet som skal returneres. 
3. Legg til en `print` statement med hva funksjonen gjør.  
4. Prøv å få tak i objektene `x` og `y` utenfor funksjonen. 

## Flere argumenter i samme funksjon 

Her definerer vi en funksjon `power` som tar to argumenter `x` og `y` og returnerer resultatet av `x` opphøyd i `y`. 

```{r, echo=TRUE, comment='#>', collapse=TRUE, error=TRUE}
# En funksjon for å opphøye ett tall i et annet 
power <- function(x, y){
  x ^ y  
}
# Definer verdier uten navngivning
power(2, 3) 
# Definer verdier med navngivning 
power(x = 2, y = 3)
# Du kan stokke om på argumentene  
power(y = 3, x = 2) 
```

## Flere argumenter i samme funksjon 

Men merk at du må spesifisere begge argumentene i funksjonen.

```{r, echo=TRUE, comment='#>', collapse=TRUE, error=TRUE}
# En funksjon for å opphøye ett tall i et annet 
power <- function(x, y){
  x ^ y  
}
power(2) # Dette funker ikke... 
```

## Standardverdier for argumenter i en funksjon 

En løsning på dette, som du også vil se i mange av Rs innebygde funksjoner, er å sette standardverdier for argumentene i funksjonen. Her har vi definert tallet 2 som standardverdi for eksponenten (`y`). 

```{r, echo=TRUE, comment='#>', collapse=TRUE, error=TRUE}
# En funksjon for å opphøye ett tall i et annet 
power <- function(x, y = 2){
  x ^ y  
}
power(2)
```

## En funksjons robusthet

Funksjonen `square_number` fungerer kun på faktiske tall. 

```{r, echo=TRUE, comment='#>', collapse=TRUE, error=TRUE}
square_number("2") 
```

## Kontrollflyt i en funksjon 

Vi kan legge til kontrollstrukturer inne i en funksjon. Her bruker vi en `if` betingelse for å konvertere `n` til en numerisk verdi **dersom** det i utgangspunktet er en tekststreng. 

```{r, echo=TRUE, comment='#>', collapse=TRUE}
square_number <- function(n){
  # Konverter tekst til numerisk  
  if(is.character(n)){
    n <- as.numeric(n)
  }
  # Multipliser 
  n * n  
} 
square_number("2")
```

## Oppgaver 

1. Lag en funksjon `multiply` som tar argumentene `x` og `y` og retunerer resultatet av `x` multiplisert med `y`. Skriv også ut en beskjed til brukeren om hva resultatet av multiplikasjonen blir, eks. `'1 ganget med 2 er lik 2'`.  
2. Legg til et argument `quiet` i funksjonen med standardverdi `FALSE`. Skriv om funksjonen slik beskjeden *ikke* skrives ut dersom `quiet` settes til `TRUE`. 
3. Skriv om funksjonen slik at den håndterer *ikke-numeriske* inputverdier. 
4. Test funksjonen med ulike verdier for `x` og `y`, eks. `10`, `"10"`, `list("10")` og `data.frame(x = 10)`. 

# God kodepraksis 
